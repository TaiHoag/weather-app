import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import customtkinter as tk
import sqlalchemy as db
import openmeteo_requests
import requests_cache
from retry_requests import retry

# API Calls
def fetch_weather_data(latitude, longitude):
    """Fetch weather data from Open Meteo API with caching and retry mechanism."""
    cache_session = requests_cache.CachedSession('.cache', expire_after=3600)
    retry_session = retry(cache_session, retries=5, backoff_factor=0.2)
    openmeteo = openmeteo_requests.Client(session=retry_session)

    url = "https://api.open-meteo.com/v1/forecast"
    params = {
        "latitude": latitude,
        "longitude": longitude,
        "hourly": ["temperature_2m", "relative_humidity_2m", "precipitation", "rain", "cloud_cover"],
        "daily": "uv_index_max",
        "timezone": "auto",
        "past_days": 3
    }
    response = openmeteo.weather_api(url, params=params)
    return response[0]

# Get City Data
def get_city_coordinates(city_name):
    """Retrieve the coordinates of a city from the Excel file."""
    try:
        city_data = pd.read_excel("worldcities/worldcities.xlsx")
        city_info = city_data[city_data['city'] == city_name]
        if not city_info.empty:
            latitude = city_info.iloc[0]['lat']
            longitude = city_info.iloc[0]['lng']
            return latitude, longitude
        else:
            print("City not found in database.")
            return None, None
    except FileNotFoundError:
        print("City coordinates file not found.")
        return None, None

def get_all_city_names():
    """Retrieve all city names from the Excel file."""
    df = pd.read_excel("worldcities/worldcities.xlsx")
    return df['city'].tolist()

# Data Processing
def process_hourly_data(response, city_name):
    """Process hourly weather data."""
    hourly = response.Hourly()
    hourly_data = {
        "date": pd.date_range(
            start=pd.to_datetime(hourly.Time(), unit="s", utc=True),
            end=pd.to_datetime(hourly.TimeEnd(), unit="s", utc=True),
            freq=pd.Timedelta(seconds=hourly.Interval()),
            inclusive="left"
        ),
        "city_name": city_name,
        "temperature_2m": hourly.Variables(0).ValuesAsNumpy(),
        "relative_humidity_2m": hourly.Variables(1).ValuesAsNumpy(),
        "precipitation": hourly.Variables(2).ValuesAsNumpy(),
        "rain": hourly.Variables(3).ValuesAsNumpy(),
        "cloud_cover": hourly.Variables(4).ValuesAsNumpy()
    }
    return pd.DataFrame(data=hourly_data)

def process_daily_data(response, city_name):
    """Process daily weather data."""
    daily = response.Daily()
    daily_data = {
        "date": pd.date_range(
            start=pd.to_datetime(daily.Time(), unit="s", utc=True),
            end=pd.to_datetime(daily.TimeEnd(), unit="s", utc=True),
            freq=pd.Timedelta(seconds=daily.Interval()),
            inclusive="left"
        ),
        "city_name": city_name,
        "uv_index_max": daily.Variables(0).ValuesAsNumpy()
    }
    return pd.DataFrame(data=daily_data)

# Store Data
def store_hourly_data(hourly_dataframe):
    """Store hourly data in the database."""
    engine = db.create_engine('sqlite:///weather_data.db')
    hourly_dataframe.to_sql('hourly_data', con=engine, if_exists='append', index=False)

def store_daily_data(daily_dataframe):
    """Store daily data in the database."""
    engine = db.create_engine('sqlite:///weather_data.db')
    daily_dataframe.to_sql('daily_data', con=engine, if_exists='append', index=False)

# Visualization
def visualize_hourly_weather(hourly_dataframe, canvas):
    """Visualize hourly weather data."""
    fig, axs = plt.subplots(2, 2, figsize=(10, 6))

    # Plot temperature
    axs[0, 0].plot(hourly_dataframe['date'], hourly_dataframe['temperature_2m'], marker='o', linestyle='-')
    axs[0, 0].set_title('Hourly Temperature Variation')
    axs[0, 0].set_xlabel('Date')
    axs[0, 0].set_ylabel('Temperature (°C)')
    axs[0, 0].tick_params(axis='x', rotation=45)
    axs[0, 0].grid(True)

    # Plot humidity
    axs[0, 1].plot(hourly_dataframe['date'], hourly_dataframe['relative_humidity_2m'], marker='o', linestyle='-')
    axs[0, 1].set_title('Hourly Humidity Variation')
    axs[0, 1].set_xlabel('Date')
    axs[0, 1].set_ylabel('Relative Humidity (%)')
    axs[0, 1].tick_params(axis='x', rotation=45)
    axs[0, 1].grid(True)

    # Plot precipitation
    axs[1, 0].plot(hourly_dataframe['date'], hourly_dataframe['precipitation'], marker='o', linestyle='-')
    axs[1, 0].set_title('Hourly Precipitation Variation')
    axs[1, 0].set_xlabel('Date')
    axs[1, 0].set_ylabel('Precipitation (mm)')
    axs[1, 0].tick_params(axis='x', rotation=45)
    axs[1, 0].grid(True)

    # Plot rain
    axs[1, 1].plot(hourly_dataframe['date'], hourly_dataframe['rain'], marker='o', linestyle='-')
    axs[1, 1].set_title('Hourly Rain Variation')
    axs[1, 1].set_xlabel('Date')
    axs[1, 1].set_ylabel('Rain (mm)')
    axs[1, 1].tick_params(axis='x', rotation=45)
    axs[1, 1].grid(True)

    fig.tight_layout()
    
    # Clear previous plots
    for widget in canvas.winfo_children():
        widget.destroy()
    
    canvas_agg = FigureCanvasTkAgg(fig, canvas)
    canvas_agg.draw()
    canvas_agg.get_tk_widget().pack(fill=tk.BOTH, expand=True)

# Display Data
def display_weather_info(city_entry, weather_text, canvas):
    """Fetch and display weather information for the selected city."""
    city_name = city_entry.get()
    latitude, longitude = get_city_coordinates(city_name)
    if latitude is None or longitude is None:
        return

    response = fetch_weather_data(latitude, longitude)

    weather_text.delete(1.0, tk.END)
    weather_text.insert(tk.END, f"City Name: {city_name}\n")
    weather_text.insert(tk.END, f"Coordinates: {latitude}°N, {longitude}°E\n\n")
    weather_text.insert(tk.END, f"Elevation: {response.Elevation()} m asl\n")
    weather_text.insert(tk.END, f"Timezone: {response.Timezone()} {response.TimezoneAbbreviation()}\n")

    hourly_dataframe = process_hourly_data(response, city_name)
    daily_dataframe = process_daily_data(response, city_name)

    store_hourly_data(hourly_dataframe)
    store_daily_data(daily_dataframe)
    visualize_hourly_weather(hourly_dataframe, canvas)

# GUI
def create_gui(fetch_weather_callback):
    """Create the GUI for the weather application."""
    root = tk.CTk()
    root.title("Weather App")
    root.geometry("1200x800")
    myfont = tk.CTkFont(family="Calibri", size=20)

    city_names = get_all_city_names()

    combobox_var = tk.StringVar(value="")
    city_entry = tk.CTkComboBox(root, width=250, values=city_names, variable=combobox_var)
    city_entry.grid(row=0, column=1, padx=5, pady=5)

    def checkkey(event):
        value = city_entry.get()
        city_list = [city for city in city_names if city.lower().startswith(value.lower())][:5]
        update_suggestions(city_list)

    def update_suggestions(city_list):
        if city_list:
            city_entry.configure(values=city_list)
        else:
            city_entry.configure(values=(""))

    city_entry.bind('<KeyRelease>', checkkey)

    fetch_button = tk.CTkButton(root, font=myfont, text="Fetch Weather", fg_color="orange", hover_color="#ff6100", command=fetch_weather_callback)
    fetch_button.grid(row=0, column=2, padx=5, pady=5)

    weather_text = tk.CTkTextbox(root, font=myfont, width=400, height=200, scrollbar_button_color="Orange", corner_radius=16, border_color="Orange", border_width=2)
    weather_text.grid(row=3, column=1, padx=5, pady=5)

    canvas = tk.CTkFrame(root)
    canvas.grid(row=4, column=1, columnspan=2, padx=5, pady=5, sticky="nsew")

    return root, city_entry, weather_text, canvas

# Main
def main():
    """Main function to run the GUI application."""
    root, city_entry, weather_text, canvas = create_gui(lambda: display_weather_info(city_entry, weather_text, canvas))
    root.mainloop()

if __name__ == "__main__":
    main()
